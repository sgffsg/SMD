<table style="width: 100%;">
  <tr>
    <td style="width: 40%;">
      <a href="./lection5.md">Основы языка C#</a>
    </td>
    <td style="width: 20%;">
      <a href="../../README.md">Содержание</a>
    </td>
    <td style="width: 40%;">
      <a href="./lection7.md">Неизвестно</a>
    </td>
  <tr>
</table>

# Основы языка C#

* [Операторы отношения и логические операторы](#Операторы_отношения_и_логические_операторы)
* [Условные операторы](#Условные_операторы)
* [Циклы](#Циклы)
* [Операторы перехода](#Операторы_перехода)

## Операторы отношения и логические операторы

В обозначениях **оператор отношения** и **логический оператор** термин *отношения* означает взаимосвязь, которая может существовать между двумя значениями, а термин *логический* — взаимосвязь между логическими значениями "истина" и "ложь". И поскольку операторы отношения дают истинные или ложные результаты, то они нередко применяются вместе с логическими операторами. Именно по этой причине они и рассматриваются совместно.

Ниже перечислены операторы отношения:

Оператор | Значение
:-------:|--------
== | Равно
!= | Не равно
`>` | Больше
`<` | Меньше
`>=` | Больше или равно
`<=` | Меньше или равно

К числу логических относятся операторы, приведенные ниже:

Оператор | Значение
:--------:|-------
& | И
\| | ИЛИ
^ | Исключающее ИЛИ
&& | Укороченное И
\|\| | Укороченное ИЛИ
! | НЕ

Результатом выполнения оператора отношения или логического оператора является логическое значение типа *bool*.

В целом, объекты можно сравнивать на равенство или неравенство, используя операторы отношения `==` и `!=`. А операторы сравнения `<`, `>`, `<=` или `>=` могут применяться только к тем типам данных, которые поддерживают отношение порядка. Следовательно, операторы отношения можно применять ко всем числовым типам данных. Но значения типа *bool* могут сравниваться только на равенство или неравенство, поскольку истинные (true) и ложные (false) значения не упорядочиваются. Например, сравнение `true > false` в C# не имеет смысла.

Рассмотрим пример программы, демонстрирующий применение операторов отношения и логических операторов:

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            short d = 10, f = 12;
            bool var1 = true, var2 = false;

            if (d < f) 
                Console.WriteLine("d < f");
            if (d <= f)
                Console.WriteLine("d <= f");
            if (d != f)
                Console.WriteLine("d != f");

            // Следующее условие не выполнится
            if (d > f)
                Console.WriteLine("d > f");

            // Сравниванием переменные var1 и var2
            if (var1 & var2)
                Console.WriteLine("Данный текст не выведется");
            if (!(var1 & var2))
                Console.WriteLine("!(var1 & var2) = true");
            if (var1 | var2)
                Console.WriteLine("var1 | var2 = true");
            if (var1 ^ var2)
                Console.WriteLine("var1 ^ var2 = true");

            Console.ReadLine();
        }

    }
}
```

Логические операторы в C# выполняют наиболее распространенные логические операции. Тем не менее существует ряд операций, выполняемых по правилам формальной логики. Эти логические операции могут быть построены с помощью логических операторов, поддерживаемых в C#. Следовательно, в C# предусмотрен такой набор логических операторов, которого достаточно для построения практически любой логической операции, в том числе импликации. **Импликация** — это двоичная операция, результатом которой является ложное значение только в том случае, если левый ее операнд имеет истинное значение, а правый — ложное. (Операция импликации отражает следующий принцип: истина не может подразумевать ложь.)

Операция импликации может быть построена на основе комбинации логических операторов ! и |:

```c#
!p | q
```

### Укороченные логические операторы

В C# предусмотрены также специальные, *укороченные*, варианты логических операторов И и ИЛИ, предназначенные для получения более эффективного кода. Поясним это на следующих примерах логических операций. Если первый операнд логической операции И имеет ложное значение (false), то ее результат будет иметь ложное значение независимо от значения второго операнда. Если же первый операнд логической операции ИЛИ имеет истинное значение (true), то ее результат будет иметь истинное значение независимо от значения второго операнда. Благодаря тому что значение второго операнда в этих операциях вычислять не нужно, *экономится время и повышается эффективность кода*.

Укороченная логическая операция И выполняется с помощью **оператора &&**, а укороченная логическая операция ИЛИ — с помощью **оператора ||**. Этим укороченным логическим операторам соответствуют обычные логические операторы & и |. Единственное отличие укороченного логического оператора от обычного заключается в том, что второй его операнд вычисляется только по мере необходимости.

Укороченные логические операторы иногда оказываются более эффективными, чем их обычные аналоги. Так зачем же нужны обычные логические операторы И и ИЛИ? Дело в том, что в некоторых случаях требуется вычислять оба операнда логической операции И либо ИЛИ из-за возникающих побочных эффектов. Пример:

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            short d = 12, f = 0, i = 0;
            bool b = true;

            // В данном случае используется укороченный оператор
            // и операции сравнения выполнится в нормальном потоке
            if (f != 0 && (d % f) == 0)
                Console.WriteLine("{0} делится нацело на {1}",d,f);

            // В этом случае так же используется укороченный оператор
            // но при этом возникнет исключительная ситуация
            // т.к. первый оператор сравнения содержит деление на 0
            if ((d % f) == 0 && f != 0)
                Console.WriteLine("{0} делится нацело на {1}", d, f);

            // При использовании целостного оператора в любом
            // случае возникнет исключительная ситуация
            if (f != 0 & (d % f) == 0)
                Console.WriteLine("{0} делится нацело на {1}", d, f);

            //*** Практический пример использования обычных операторов ***//
            // При использовании обычного оператора, в данной конструкции 
            // i будет инкреминироваться
            if (b | (++i < 10))
                Console.WriteLine("i равно {0}", i);   // i = 1

            i = 0;
            // При использовании укороченного оператора
            // значение i останется прежним
            if (b || (++i < 10))
                Console.WriteLine("i равно {0}", i);  // i = 0

            Console.ReadLine();
        }

    }
}
```


## Условные операторы

Условные операторы позволяют управлять *потоком выполнения* программы, чтобы выполнялась та часть кода, соответсвующая необходимым условиям.
Условные конструкции - один из базовых компонентов многих языков программирования, которые направляют работу программы по одному из путей в зависимости от определенных условий.

### Оператор if

Для организации условного ветвления язык C# унаследовал от С и С++ конструкцию if...else. Конструкция if/else проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код. Ее простейшая форма состоит из блока if:

```cs
if (условие)
{
    выполняемые инструкции
}
else
{
    выполняемые инструкции
}
```

После ключевого слова if ставится условие. Условие должно представлять значение типа bool. Это может быть непосредственно значение типа bool или результат условного выражения или другого выражения, которое возвращает значение типа bool. И если это условие истинно (равно true), то срабатывает код, который помещен далее после условия внутри фигурных скобок.

Если по каждому из условий нужно выполнить более одного оператора, эти операторы должны быть объединены в блок с помощью фигурных скобок {...}.

Например:
```cs
int num1 = 8;
int num2 = 6;
if (num1 > num2)
{
    Console.WriteLine($"Число {num1} больше числа {num2}");
}
```

Если блок if содержит одну инструкцию, то мы можем его сократить, убрав фигурные скобки:
```cs
int num1 = 8;
int num2 = 6;
if (num1 > num2)
    Console.WriteLine($"Число {num1} больше числа {num2}");
```

Также мы можем соединить сразу несколько условий, используя логические операторы:
```cs
int num1 = 8;
int num2 = 6;
if(num1 > num2 && num1==8)
{
    Console.WriteLine($"Число {num1} больше числа {num2}");
}
```

В данном случае блок if будет выполняться, если num1 > num2 равно true и num1==8 равно true.

В операторе if могут применяться сложные выражения, и он может содержать операторы else, обеспечивая выполнение более сложных проверок. 

Блок else выполняется, если условие после if ложно, то есть равно false. Если блок else содержит толко одну инструкцию, то оять же мы можем его сократить, убрав фигурные скобки:


### Оператор switch

Вторым оператором выбора в C# является оператор **switch**, который обеспечивает многонаправленное ветвление программы. Следовательно, этот оператор позволяет сделать выбор среди нескольких альтернативных вариантов дальнейшего выполнения программы. Несмотря на то что многонаправленная проверка может быть организована с помощью последовательного ряда вложенных операторов if, во многих случаях более эффективным оказывается применение оператора switch. Этот оператор действует следующим образом. Значение выражения последовательно сравнивается с константами выбора из заданного списка. Как только будет обнаружено совпадение с одним из условий выбора, выполняется последовательность операторов, связанных с этим условием. Ниже приведена общая форма оператора switch:

```cs
switch(выражение) {
    case значение1:
        последовательность операторов
        break;
    case значение1:
        последовательность операторов
        break;
    case значение1:
        последовательность операторов
        break;

    ...

    default:
        последовательность операторов
        break;
}
```

Хотя оператор switch...case должен быть знаком программистам на С и С++, в C# он немного безопаснее, чем его эквивалент С++. В частности, он запрещает "сквозные" условия почти во всех случаях. Это значит, что если часть case вызывается в начале блока, то фрагменты кода за последующими частями case не выполняются. Компилятор обеспечивает это ограничение за счет того, что требует, чтобы за каждой частью *case* следовал оператор *break*, в противном случае он выдает ошибку.

Важно отметить, что заданное выражение в операторе *switch* должно быть *целочисленного типа* (char, byte, short или int), *перечислимого* или же *строкового*. А выражения других типов, например с плавающей точкой, в операторе switch не допускаются. Зачастую выражение, управляющее оператором *switch*, просто сводится к одной переменной. Кроме того, константы выбора должны иметь тип, совместимый с типом выражения. В одном операторе *switch* не допускается наличие двух одинаковых по значению констант выбора.

Давайте на примере рассмотрим использование оператора *switch*:

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Введите язык (C#, VB или C++)");
            string myLanguage = Console.ReadLine();

            switch (myLanguage)
            {
                case "C#":
                    Console.WriteLine("Вы выбрали язык C#");
                    break;
                case "VB":
                    Console.WriteLine("Вы выбрали язык Visual Basic");
                    break;
                case "C++":
                    Console.WriteLine("Вы выбрали язык С++");
                    break;
                default:
                    Console.WriteLine("Такой язык я не знаю");
                    break;
            }

            Console.ReadKey();
        }
    }
}
```

## Циклы

В C# имеются четыре различных вида циклов (for, while, do...while и foreach), позволяющие выполнять блок кода повторно до тех пор, пока удовлетворяется определенное условие. В этой лекции мы познакомимся с циклами *for* и *while*.

### Цикл for

Цикл for в C# предоставляет механизм итерации, в котором определенное условие проверяется перед выполнением каждой итерации. Синтаксис этого оператора показан ниже:

```cs
for (действия_до_выполнения_цикла; условие; действия_после_выполнения)
{
    // действия
}
```
Объявление цикла for состоит из трех частей. 

Первая часть объявления цикла - **инициализатор** - некоторые действия, которые выполняются один раз до выполнения цикла. Инициализация, как правило, представлена оператором присваивания, задающим первоначальное значение переменной, которая выполняет роль счетчика и управляет циклом;

Вторая часть - **условие**, при котором будет выполняться цикл. Пока условие равно true, будет выполняться цикл.

И третья часть - **итератор** - выражение, вычисляемое после каждой итерации (обычно приращение значения счетчика цикла).

Обратите внимание на то, что эти три основные части оператора цикла for должны быть разделены точкой с запятой. Выполнение цикла for будет продолжаться до тех пор, пока проверка условия дает истинный результат. Как только эта проверка даст ложный результат, цикл завершится, а выполнение программы будет продолжено с оператора, следующего после цикла for.

```c#
for (int i = 1; i < 4; i++)
{
    Console.WriteLine(i);
}
```

### Цикл while

Подобно for, while также является циклом с предварительной проверкой. Синтаксис его аналогичен, но циклы while включают только одно выражение:

```cs
while (условие) 
{
    операторы;
} 
```

где *оператор* — это единственный оператор или же блок операторов, а условие означает конкретное условие управления циклом и может быть любым логическим выражением. В этом цикле оператор выполняется до тех пор, пока условие истинно. Как только условие становится ложным, управление программой передается строке кода, следующей непосредственно после цикла.

Как и в цикле for, в цикле while проверяется условное выражение, указываемое в самом начале цикла. Это означает, что код в теле цикла может вообще не выполняться, а также избавляет от необходимости выполнять отдельную проверку перед самим циклом.

Пример:

```c#
byte l = 2, i = 0;
int result = 1;
while (i < 10)
{
    i++;
    result *= l;
    Console.WriteLine($"Число {l} в степени {i} равно {result}");
}
Console.ReadLine();
```


### Цикл do. . . while

Цикл do...while в C# — это версия while с постпроверкой условия. Это значит, что условие цикла проверяется после выполнения тела цикла. Следовательно, циклы do...while удобны в тех ситуациях, когда блок операторов должен быть выполнен как минимум однажды. Ниже приведена общая форма оператора цикла do-while:

```cs
do {
    операторы;
} while (условие);
```

В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while. И пока это условие истинно, цикл повторяется.

Цикл do-while выполняется до тех пор, пока условное выражение истинно. В качестве примера использования цикла do-while можно привести следующую программу, расчитывающую факториал числа:

```c#
// Вычисляем факториал числа
int i, result = 1, num = 1;

Console.WriteLine("Введите число:");
i = int.Parse(Console.ReadLine());

Console.WriteLine("\nФакториал  числа " + i);

do
{
    result *= num;
    num++;
} while (num <= i);

Console.WriteLine(result);
```

### Цикл foreach

Цикл foreach служит для циклического обращения к элементам **коллекции**, представляющей собой группу объектов. В C# определено несколько видов коллекций, каждая из которых является массивом. Ниже приведена общая форма оператора цикла foreach:

```cs
foreach (тип имя_переменной_цикла in коллекция) 
{
    оператор;
}
```

Здесь *тип имя_переменной_цикла* обозначает тип и имя переменной управления циклом, которая получает значение следующего элемента коллекции на каждом шаге выполнения цикла foreach. А *коллекция* обозначает циклически опрашиваемую коллекцию, которая здесь и далее представляет собой массив. Следовательно, тип переменной цикла должен соответствовать типу элемента массива. Кроме того, тип может обозначаться ключевым словом var. В этом случае компилятор определяет тип переменной цикла, исходя из типа элемента массива. Это может оказаться полезным для работы с определенного рода запросами. Но, как правило, тип указывается явным образом.

Оператор цикла foreach действует следующим образом. Когда цикл начинается, первый элемент массива выбирается и присваивается переменной цикла. На каждом последующем шаге итерации выбирается следующий элемент массива, который сохраняется в переменной цикла. Цикл завершается, когда все элементы массива окажутся выбранными.

Цикл foreach позволяет проходить по каждому элементу коллекции (объект, представляющий список других объектов). Формально для того, чтобы нечто можно было рассматривать как коллекцию, это нечто должно поддерживать интерфейс IEnumerable. Примерами коллекций могут служить массивы C#, классы коллекций из пространства имен System.Collection, а также пользовательские классы коллекций.


## Операторы перехода

Язык C# предлагает несколько операторов, позволяющих немедленно перейти на другую строку программы. Давайте их рассмотрим.

### Оператор goto

Имеющийся в C# оператор goto представляет собой оператор безусловного перехода. Когда в программе встречается оператор goto, ее выполнение переходит непосредственно к тому месту, на которое указывает этот оператор. Он уже давно "вышел из употребления" в программировании, поскольку способствует созданию "макаронного" кода. Хотя в некоторых случаях он оказывается удобным и дает определенные преимущества, если используется благоразумно. Главный недостаток оператора goto с точки зрения программирования заключается в том, что он вносит в программу беспорядок и делает ее практически неудобочитаемой. Но иногда применение оператора goto может, скорее, прояснить, чем запутать ход выполнения программы.

Для выполнения оператора goto требуется метка — действительный в C# идентификатор с двоеточием. Метка должна находиться в том же методе, где и оператор goto, а также в пределах той же самой области действия.

Репутация оператора goto такова, что в большинстве случаев его применение категорически осуждается. Вообще говоря, он, конечно, не вписывается в рамки хорошей практики объектно-ориентированного программирования.

### Оператор break

С помощью оператора break можно специально организовать немедленный выход из цикла в обход любого кода, оставшегося в теле цикла, а также минуя проверку условия цикла. Когда в теле цикла встречается оператор break, цикл завершается, а выполнение программы возобновляется с оператора, следующего после этого цикла. Оператор break можно применять в любом цикле, предусмотренном в C#.

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            // В данном цикле выведутся числа от 1 до 5 вместо 100
            for (int i = 1; i < 100; i++)
                if (i <= 5)
                    Console.WriteLine(i);
                else break;

            Console.ReadLine();
        }
    }
}
```

Обратите внимание если оператор break применяется в целом ряде вложенных циклов, то он прерывает выполнение только самого внутреннего цикла.

В отношении оператора break необходимо также иметь в виду следующее. Во-первых, в теле цикла может присутствовать несколько операторов break, но применять их следует очень аккуратно, поскольку чрезмерное количество операторов break обычно приводит к нарушению нормальной структуры кода. И во-вторых, оператор break, выполняющий выход из оператора switch, оказывает воздействие только на этот оператор, но не на объемлющие его циклы.

### Оператор continue

С помощью оператора continue можно организовать преждевременное завершение шага итерации цикла в обход обычной структуры управления циклом. Оператор continue осуществляет принудительный переход к следующему шагу цикла, пропуская любой код, оставшийся невыполненным. Таким образом, оператор continue служит своего рода дополнением оператора break.

В циклах while и do-while оператор continue вызывает передачу управления непосредственно условному выражению, после чего продолжается процесс выполнения цикла. А в цикле for сначала вычисляется итерационное выражение, затем условное выражение, после чего цикл продолжается:

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            // Выводим числа кратные 5
            for (byte i = 1; i <= 100; i++)
            {
                if (i % 5 != 0) continue;
                Console.Write("\t{0}", i);
            }

            Console.ReadLine();
        }
    }
}
```

Оператор continue редко находит удачное применение, в частности, потому, что в C# предоставляется богатый набор операторов цикла, удовлетворяющих большую часть прикладных потребностей. Но в тех особых случаях, когда требуется преждевременное прерывание шага итерации цикла, оператор continue предоставляет структурированный способ осуществления такого прерывания.

### Оператор return

Оператор return организует возврат из метода. Его можно также использовать для возврата значения. Имеются две формы оператора return: одна — для методов типа void, т.е. тех методов, которые не возвращают значения, а другая — для методов, возвращающих конкретные значения.

Для немедленного завершения метода типа void достаточно воспользоваться следующей формой оператора return:

```cs
return;
```

Когда выполняется этот оператор, управление возвращается вызывающей части программы, а оставшийся в методе код пропускается.

Для возврата значения из метода в вызывающую часть программы служит следующая форма оператора return:

```cs
return значение;
```

Давайте рассмотрим применение оператора return на конкретном примере:

```c#
static void Main(string[] args)
{
    int result = Sum(230);
    Console.WriteLine("Сумма четных чисел от 1 до 230 равна: " + result);
    Console.ReadLine();
}

// Метод, возращающий сумму всех  чисел
// от 1 до s
int Sum(int s)
{
    int Sum = 0;
    for (int i = 1; i <= s; i++)
            Sum += i;
    return Sum;
}
```

<table style="width: 100%;">
  <tr>
    <td style="width: 40%;">
      <a href="./lection5.md">Основы языка C#</a>
    </td>
    <td style="width: 20%;">
      <a href="../../README.md">Содержание</a>
    </td>
    <td style="width: 40%;">
      <a href="./lection7.md">Неизвестно</a>
    </td>
  <tr>
</table>
